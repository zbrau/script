local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer

--[[----------------------------------------------------------------------------------------------------------
                                        VARIABLES GLOBALES Y DE ESTADO
----------------------------------------------------------------------------------------------------------]]

-- Variables del ESP
local ESPConnection
local ESPSettings = {
    Innocent = {chams = false, tracer = false, box = false},
    Sheriff = {chams = false, tracer = false, box = false},
    Murder = {chams = false, tracer = false, box = false}
}
local TracerLines = {}
local BoxESP = {}

-- Variables del Speed Glitch
local speedGlitchConnection
local speedGlitchEnabled = false
local speedGlitchValue = 16 -- Velocidad por defecto (equivalente a la normal)
local originalWalkSpeed = nil

-- **NUEVA** Variable para el estado minimizado
local isMinimized = false
local originalMainFrameSize = UDim2.new(0, 350, 0, 250)

--[[----------------------------------------------------------------------------------------------------------
                                        LÓGICA DE FUNCIONALIDADES
----------------------------------------------------------------------------------------------------------]]

-- Función para limpiar ESP de un jugador específico
local function CleanupPlayerESP(playerName)
    if TracerLines[playerName] then
        TracerLines[playerName]:Remove()
        TracerLines[playerName] = nil
    end
    if BoxESP[playerName] then
        for _, line in pairs(BoxESP[playerName]) do
            if line and line.Remove then line:Remove() end
        end
        BoxESP[playerName] = nil
    end
end

Players.PlayerRemoving:Connect(function(player)
    CleanupPlayerESP(player.Name)
end)

-- Funciones del ESP (sin cambios)
local function GetRoleColor(role)
    if role == "Sheriff" then return Color3.fromRGB(0, 0, 255)
    elseif role == "Murder" then return Color3.fromRGB(255, 0, 0)
    else return Color3.fromRGB(0, 255, 0) end
end

local function CreateChams(player, color)
    if not player.Character then return end
    local humanoid = player.Character:FindFirstChild("Humanoid")
    if not humanoid or humanoid.Health <= 0 then
        if player.Character:FindFirstChild("ESP_Highlight") then
            player.Character.ESP_Highlight:Destroy()
        end
        return
    end
    local highlight = player.Character:FindFirstChild("ESP_Highlight") or Instance.new("Highlight")
    highlight.Name = "ESP_Highlight"
    highlight.Parent = player.Character
    highlight.Adornee = player.Character
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    highlight.FillColor = color
    if color == Color3.fromRGB(255, 0, 0) then
        highlight.OutlineColor = Color3.fromRGB(255, 100, 100)
        highlight.FillTransparency = 0.2
    elseif color == Color3.fromRGB(0, 0, 255) then
        highlight.OutlineColor = Color3.fromRGB(100, 100, 255)
        highlight.FillTransparency = 0.25
    else
        highlight.OutlineColor = Color3.fromRGB(100, 255, 100)
        highlight.FillTransparency = 0.35
    end
end

local function CreateTracer(player, color)
    if not player or not Players:FindFirstChild(player.Name) then
        if TracerLines[player.Name] then TracerLines[player.Name]:Remove(); TracerLines[player.Name] = nil; end
        return
    end
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") or player.Character.Humanoid.Health <= 0 then
        if TracerLines[player.Name] then TracerLines[player.Name].Visible = false; end
        return
    end
    local rootPart = player.Character.HumanoidRootPart
    local line = TracerLines[player.Name] or Drawing.new("Line")
    TracerLines[player.Name] = line
    local camera = workspace.CurrentCamera
    local rootPosition, onScreen = camera:WorldToViewportPoint(rootPart.Position)
    if onScreen and rootPosition.Z > 0 then
        line.From = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y)
        line.To = Vector2.new(rootPosition.X, rootPosition.Y)
        line.Color = color; line.Thickness = 2; line.Transparency = 1; line.Visible = true
    else
        line.Visible = false
    end
end

local function CreateBox(player, color)
    if not player or not Players:FindFirstChild(player.Name) then
        if BoxESP[player.Name] then for _, l in pairs(BoxESP[player.Name]) do l:Remove() end; BoxESP[player.Name] = nil; end
        return
    end
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") or player.Character.Humanoid.Health <= 0 then
        if BoxESP[player.Name] then for _, l in pairs(BoxESP[player.Name]) do l.Visible = false end end
        return
    end
    local box = BoxESP[player.Name]
    if not box then
        box = {topSide=Drawing.new("Line"),bottomSide=Drawing.new("Line"),leftSide=Drawing.new("Line"),rightSide=Drawing.new("Line")}
        BoxESP[player.Name] = box
    end
    local camera = workspace.CurrentCamera
    local rootPart = player.Character.HumanoidRootPart
    local rootPos, onScreen = camera:WorldToViewportPoint(rootPart.Position)
    if onScreen and rootPos.Z > 0 then
        local headPos = camera:WorldToViewportPoint(rootPart.Position + Vector3.new(0, 2, 0))
        local legPos = camera:WorldToViewportPoint(rootPart.Position + Vector3.new(0, -3, 0))
        local height = math.abs(headPos.Y - legPos.Y)
        local width = height * 0.6
        local x1, x2, y1, y2 = rootPos.X - width/2, rootPos.X + width/2, headPos.Y, legPos.Y
        local lines = {{box.topSide, Vector2.new(x1, y1), Vector2.new(x2, y1)}, {box.bottomSide, Vector2.new(x1, y2), Vector2.new(x2, y2)}, {box.leftSide, Vector2.new(x1, y1), Vector2.new(x1, y2)}, {box.rightSide, Vector2.new(x2, y1), Vector2.new(x2, y2)}}
        for _, d in pairs(lines) do local l, f, t = d[1], d[2], d[3]; l.From, l.To, l.Color, l.Thickness, l.Transparency, l.Visible = f, t, color, 2, 1, true end
    else
        for _, l in pairs(box) do if l then l.Visible = false end end
    end
end

local function RemoveESP(player)
    if player.Character and player.Character:FindFirstChild("ESP_Highlight") then
        player.Character.ESP_Highlight:Destroy()
    end
    if TracerLines[player.Name] then
        TracerLines[player.Name]:Remove()
        TracerLines[player.Name] = nil
    end
    if BoxESP[player.Name] then
        for _, line in pairs(BoxESP[player.Name]) do line:Remove() end
        BoxESP[player.Name] = nil
    end
end

local function DetectRole(player)
    local function hasTool(name)
        return (player.Backpack:FindFirstChild(name) or (player.Character and player.Character:FindFirstChild(name)))
    end
    if hasTool("Gun") or hasTool("IsGun") then return "Sheriff"
    elseif hasTool("Knife") then return "Murder"
    else return "Innocent" end
end

local function ToggleESP()
    if ESPConnection then ESPConnection:Disconnect(); ESPConnection = nil; end
    for _, player in pairs(Players:GetPlayers()) do RemoveESP(player) end
    for playerName in pairs(TracerLines) do if not Players:FindFirstChild(playerName) then CleanupPlayerESP(playerName) end end
    for playerName in pairs(BoxESP) do if not Players:FindFirstChild(playerName) then CleanupPlayerESP(playerName) end end
    local anyEnabled = false
    for _, settings in pairs(ESPSettings) do for _, enabled in pairs(settings) do if enabled then anyEnabled = true; break; end end if anyEnabled then break; end end
    if anyEnabled then
        ESPConnection = RunService.Heartbeat:Connect(function()
            for _, player in pairs(Players:GetPlayers()) do
                if player ~= LocalPlayer and player.Character then
                    local role = DetectRole(player)
                    local color = GetRoleColor(role)
                    if ESPSettings[role] then
                        if ESPSettings[role].chams then CreateChams(player, color)
                        else if player.Character:FindFirstChild("ESP_Highlight") then player.Character.ESP_Highlight:Destroy() end end
                        if ESPSettings[role].tracer then CreateTracer(player, color)
                        elseif TracerLines[player.Name] then TracerLines[player.Name].Visible = false end
                        if ESPSettings[role].box then CreateBox(player, color)
                        elseif BoxESP[player.Name] then for _, l in pairs(BoxESP[player.Name]) do l.Visible = false end end
                    else RemoveESP(player) end
                end
            end
        end)
    end
end

-- Función para el Speed Glitch
local function UpdateSpeedGlitch()
    local char = LocalPlayer.Character
    if not char or not char:FindFirstChild("Humanoid") then return end
    
    local humanoid = char.Humanoid
    local onGround = humanoid:GetState() == Enum.HumanoidStateType.Running or humanoid:GetState() == Enum.HumanoidStateType.Landed
    local isMoving = humanoid.MoveDirection.Magnitude > 0
    
    -- Si el jugador está en el aire Y se está moviendo
    if not onGround and isMoving then
        if not originalWalkSpeed then
            originalWalkSpeed = humanoid.WalkSpeed
        end
        humanoid.WalkSpeed = speedGlitchValue
    else
        -- Si ya no cumple las condiciones, restaurar la velocidad original
        if originalWalkSpeed then
            humanoid.WalkSpeed = originalWalkSpeed
            originalWalkSpeed = nil -- Limpiar para el próximo salto
        end
    end
end

--[[----------------------------------------------------------------------------------------------------------
                                        CREACIÓN DE LA INTERFAZ (GUI)
----------------------------------------------------------------------------------------------------------]]

-- Limpiar GUI anterior si existe
if LocalPlayer.PlayerGui:FindFirstChild("MurderMysteryGUI") then LocalPlayer.PlayerGui.MurderMysteryGUI:Destroy() end

-- Crear GUI Principal
local ScreenGui = Instance.new("ScreenGui", LocalPlayer:WaitForChild("PlayerGui"))
ScreenGui.Name = "MurderMysteryGUI"; ScreenGui.ResetOnSpawn = false; ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

local MainFrame = Instance.new("Frame", ScreenGui)
MainFrame.Name = "MainFrame"; MainFrame.Size = originalMainFrameSize; MainFrame.Position = UDim2.new(0.5, -175, 0.5, -125); MainFrame.BackgroundColor3 = Color3.fromRGB(45, 45, 45); MainFrame.BorderSizePixel = 0
local MainCorner = Instance.new("UICorner", MainFrame); MainCorner.CornerRadius = UDim.new(0, 8)

local TitleBar = Instance.new("Frame", MainFrame)
TitleBar.Name = "TitleBar"; TitleBar.Size = UDim2.new(1, 0, 0, 30); TitleBar.BackgroundColor3 = Color3.fromRGB(35, 35, 35); TitleBar.Active = true
local TitleCorner = Instance.new("UICorner", TitleBar); TitleCorner.CornerRadius = UDim.new(0, 8)

local TitleLabel = Instance.new("TextLabel", TitleBar)
TitleLabel.Size = UDim2.new(1, -115, 1, 0); TitleLabel.Position = UDim2.new(0, 10, 0, 0); TitleLabel.BackgroundTransparency = 1; TitleLabel.Text = "Murder Mystery GUI"; TitleLabel.TextColor3 = Color3.new(1, 1, 1); TitleLabel.TextScaled = true; TitleLabel.Font = Enum.Font.GothamBold

-- **NUEVO** Botón de Minimizar
local MinimizeButton = Instance.new("TextButton", TitleBar)
MinimizeButton.Size = UDim2.new(0, 25, 0, 25); MinimizeButton.Position = UDim2.new(1, -60, 0, 2.5); MinimizeButton.BackgroundColor3 = Color3.fromRGB(255, 165, 0); MinimizeButton.Text = "_"; MinimizeButton.TextColor3 = Color3.new(1, 1, 1); MinimizeButton.TextScaled = true; MinimizeButton.Font = Enum.Font.GothamBold
local MinimizeCorner = Instance.new("UICorner", MinimizeButton); MinimizeCorner.CornerRadius = UDim.new(0, 4)

local CloseButton = Instance.new("TextButton", TitleBar)
CloseButton.Size = UDim2.new(0, 25, 0, 25); CloseButton.Position = UDim2.new(1, -30, 0, 2.5); CloseButton.BackgroundColor3 = Color3.fromRGB(255, 85, 85); CloseButton.Text = "X"; CloseButton.TextColor3 = Color3.new(1, 1, 1); CloseButton.TextScaled = true; CloseButton.Font = Enum.Font.GothamBold
local CloseCorner = Instance.new("UICorner", CloseButton); CloseCorner.CornerRadius = UDim.new(0, 4)

local TabFrame = Instance.new("Frame", MainFrame)
TabFrame.Size = UDim2.new(1, 0, 0, 35); TabFrame.Position = UDim2.new(0, 0, 0, 30); TabFrame.BackgroundColor3 = Color3.fromRGB(55, 55, 55)

local ContentFrame = Instance.new("Frame", MainFrame)
ContentFrame.Size = UDim2.new(1, 0, 1, -65); ContentFrame.Position = UDim2.new(0, 0, 0, 65); ContentFrame.BackgroundTransparency = 1

local currentTab = "Visual"
local tabs = {"Visual", "Combat", "Main"}
local tabButtons = {}
local tabContents = {}

for i, tabName in ipairs(tabs) do
    local TabButton = Instance.new("TextButton", TabFrame)
    TabButton.Size = UDim2.new(1/3, -2, 1, -4); TabButton.Position = UDim2.new((i-1)/3, 1, 0, 2); TabButton.BackgroundColor3 = tabName == currentTab and Color3.fromRGB(75, 75, 75) or Color3.fromRGB(65, 65, 65); TabButton.Text = tabName; TabButton.TextColor3 = Color3.new(1, 1, 1); TabButton.TextScaled = true; TabButton.Font = Enum.Font.Gotham
    local TabCorner = Instance.new("UICorner", TabButton); TabCorner.CornerRadius = UDim.new(0, 4)
    tabButtons[tabName] = TabButton
end

for _, tabName in ipairs(tabs) do
    local TabContent = Instance.new("ScrollingFrame", ContentFrame)
    TabContent.Size = UDim2.new(1, -10, 1, -10); TabContent.Position = UDim2.new(0, 5, 0, 5); TabContent.BackgroundTransparency = 1; TabContent.ScrollBarThickness = 4; TabContent.ScrollBarImageColor3 = Color3.fromRGB(75, 75, 75); TabContent.CanvasSize = UDim2.new(0, 0, 0, 300); TabContent.Visible = tabName == currentTab
    tabContents[tabName] = TabContent
end

local function SwitchTab(tabName)
    currentTab = tabName
    for name, button in pairs(tabButtons) do button.BackgroundColor3 = name == tabName and Color3.fromRGB(75, 75, 75) or Color3.fromRGB(65, 65, 65) end
    for name, content in pairs(tabContents) do content.Visible = name == tabName end
end

for tabName, button in pairs(tabButtons) do
    button.MouseButton1Click:Connect(function() SwitchTab(tabName) end)
end

-- **NUEVA** Función para minimizar/maximizar
local function ToggleMinimize()
    isMinimized = not isMinimized
    
    if isMinimized then
        -- Minimizar: solo mostrar la barra de título
        MainFrame.Size = UDim2.new(0, 350, 0, 30)
        TabFrame.Visible = false
        ContentFrame.Visible = false
        MinimizeButton.Text = "□"  -- Cambiar icono a maximize
        MinimizeButton.BackgroundColor3 = Color3.fromRGB(85, 170, 85)  -- Verde para maximize
    else
        -- Maximizar: mostrar toda la ventana
        MainFrame.Size = originalMainFrameSize
        TabFrame.Visible = true
        ContentFrame.Visible = true
        MinimizeButton.Text = "_"  -- Cambiar icono a minimize
        MinimizeButton.BackgroundColor3 = Color3.fromRGB(255, 165, 0)  -- Naranja para minimize
    end
end

-- Función para crear botones toggle
local function CreateToggleButton(parent, text, defaultState, callback)
    local ToggleFrame = Instance.new("Frame", parent)
    ToggleFrame.Size = UDim2.new(1, 0, 0, 25); ToggleFrame.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    Instance.new("UICorner", ToggleFrame).CornerRadius = UDim.new(0, 4)
    local Label = Instance.new("TextLabel", ToggleFrame)
    Label.Size = UDim2.new(1, -50, 1, 0); Label.Position = UDim2.new(0, 5, 0, 0); Label.BackgroundTransparency = 1; Label.Text = text; Label.TextColor3 = Color3.new(1, 1, 1); Label.TextXAlignment = Enum.TextXAlignment.Left; Label.TextScaled = true; Label.Font = Enum.Font.Gotham
    local ToggleButton = Instance.new("TextButton", ToggleFrame)
    ToggleButton.Size = UDim2.new(0, 40, 0, 18); ToggleButton.Position = UDim2.new(1, -43, 0.5, -9); ToggleButton.BackgroundColor3 = defaultState and Color3.fromRGB(85, 170, 85) or Color3.fromRGB(170, 85, 85); ToggleButton.Text = defaultState and "ON" or "OFF"; ToggleButton.TextColor3 = Color3.new(1, 1, 1); ToggleButton.TextScaled = true; ToggleButton.Font = Enum.Font.GothamBold
    Instance.new("UICorner", ToggleButton).CornerRadius = UDim.new(0, 3)
    local isToggled = defaultState
    ToggleButton.MouseButton1Click:Connect(function()
        isToggled = not isToggled
        ToggleButton.BackgroundColor3 = isToggled and Color3.fromRGB(85, 170, 85) or Color3.fromRGB(170, 85, 85)
        ToggleButton.Text = isToggled and "ON" or "OFF"
        callback(isToggled)
    end)
    return ToggleFrame
end

-- Función para crear sliders
local function CreateSlider(parent, text, min, max, default, callback)
    local SliderFrame = Instance.new("Frame", parent)
    SliderFrame.Size = UDim2.new(1, 0, 0, 40); SliderFrame.BackgroundColor3 = Color3.fromRGB(60, 60, 60); SliderFrame.BorderSizePixel = 0
    Instance.new("UICorner", SliderFrame).CornerRadius = UDim.new(0, 4)

    local Label = Instance.new("TextLabel", SliderFrame)
    Label.Size = UDim2.new(0.7, 0, 0, 15); Label.Position = UDim2.new(0.02, 0, 0, 0); Label.BackgroundTransparency = 1; Label.TextColor3 = Color3.new(1, 1, 1); Label.TextXAlignment = Enum.TextXAlignment.Left; Label.Font = Enum.Font.Gotham; Label.Text = text

    local ValueLabel = Instance.new("TextLabel", SliderFrame)
    ValueLabel.Size = UDim2.new(0.3, -5, 0, 15); ValueLabel.Position = UDim2.new(0.7, 0, 0, 0); ValueLabel.BackgroundTransparency = 1; ValueLabel.TextColor3 = Color3.new(1, 1, 1); ValueLabel.TextXAlignment = Enum.TextXAlignment.Right; ValueLabel.Font = Enum.Font.GothamBold

    local Track = Instance.new("Frame", SliderFrame)
    Track.Size = UDim2.new(1, -10, 0, 6); Track.Position = UDim2.new(0, 5, 1, -12); Track.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    Instance.new("UICorner", Track).CornerRadius = UDim.new(0, 3)

    local Progress = Instance.new("Frame", Track)
    Progress.Size = UDim2.new(0, 0, 1, 0); Progress.BackgroundColor3 = Color3.fromRGB(85, 170, 85)
    Instance.new("UICorner", Progress).CornerRadius = UDim.new(0, 3)

    local draggingSlider = false

    local function updateSlider(inputX)
        local relativeX = math.clamp(inputX - Track.AbsolutePosition.X, 0, Track.AbsoluteSize.X)
        local percent = relativeX / Track.AbsoluteSize.X
        Progress.Size = UDim2.new(percent, 0, 1, 0)
        local value = min + (max - min) * percent
        ValueLabel.Text = string.format("%.1f", value)
        callback(value)
    end

    Track.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            draggingSlider = true
            updateSlider(input.Position.X)
        end
    end)
    
    Track.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            draggingSlider = false
        end
    end)
    
    UserInputService.InputChanged:Connect(function(input)
        if draggingSlider and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
            updateSlider(input.Position.X)
        end
    end)
    
    -- Inicializar valor
    local initialPercent = (default - min) / (max - min)
    Progress.Size = UDim2.new(initialPercent, 0, 1, 0)
    ValueLabel.Text = string.format("%.1f", default)
    
    return SliderFrame
end

--[[----------------------------------------------------------------------------------------------------------
                                     CONTENIDO DE LAS PESTAÑAS
----------------------------------------------------------------------------------------------------------]]

-- Agregar layout a Visual
local VisualLayout = Instance.new("UIListLayout", tabContents["Visual"])
VisualLayout.SortOrder = Enum.SortOrder.LayoutOrder; VisualLayout.Padding = UDim.new(0, 3)

-- Contenido de la pestaña Visual (ESP)
local function createESPCategory(parent, title, color, baseOrder, role)
    local Label = Instance.new("TextLabel", parent); Label.Size = UDim2.new(1, 0, 0, 20); Label.BackgroundColor3 = color; Label.Text = title; Label.TextColor3 = Color3.new(1, 1, 1); Label.TextScaled = true; Label.Font = Enum.Font.GothamBold; Label.LayoutOrder = baseOrder
    Instance.new("UICorner", Label).CornerRadius = UDim.new(0, 4)
    CreateToggleButton(parent, "Chams", false, function(s) ESPSettings[role].chams = s; ToggleESP() end).LayoutOrder = baseOrder + 1
    CreateToggleButton(parent, "Tracer", false, function(s) ESPSettings[role].tracer = s; ToggleESP() end).LayoutOrder = baseOrder + 2
    CreateToggleButton(parent, "Box", false, function(s) ESPSettings[role].box = s; ToggleESP() end).LayoutOrder = baseOrder + 3
end
createESPCategory(tabContents["Visual"], "INNOCENT ESP", Color3.fromRGB(0, 150, 0), 1, "Innocent")
createESPCategory(tabContents["Visual"], "SHERIFF ESP", Color3.fromRGB(0, 0, 255), 5, "Sheriff")
createESPCategory(tabContents["Visual"], "MURDER ESP", Color3.fromRGB(255, 0, 0), 9, "Murder")

-- Agregar layout y contenido a Main
local MainLayout = Instance.new("UIListLayout", tabContents["Main"])
MainLayout.SortOrder = Enum.SortOrder.LayoutOrder; MainLayout.Padding = UDim.new(0, 3)

CreateToggleButton(tabContents["Main"], "Fake Speed Glitch", false, function(state)
    speedGlitchEnabled = state
    if speedGlitchEnabled then
        speedGlitchConnection = RunService.Heartbeat:Connect(UpdateSpeedGlitch)
    else
        if speedGlitchConnection then
            speedGlitchConnection:Disconnect()
            speedGlitchConnection = nil
        end
        -- Restaurar velocidad si se desactiva
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") and originalWalkSpeed then
            LocalPlayer.Character.Humanoid.WalkSpeed = originalWalkSpeed
            originalWalkSpeed = nil
        end
    end
end).LayoutOrder = 1

CreateSlider(tabContents["Main"], "Speed", 16, 100, 16, function(value)
    speedGlitchValue = value
end).LayoutOrder = 2

--[[----------------------------------------------------------------------------------------------------------
                                        MANEJO DE EVENTOS DE LA GUI
----------------------------------------------------------------------------------------------------------]]

-- Hacer el GUI arrastrable
local dragging = false
local dragStart, startPos = nil, nil
TitleBar.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true; dragStart = input.Position; startPos = MainFrame.Position
    end
end)
TitleBar.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = false
    end
end)
UserInputService.InputChanged:Connect(function(input)
    if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
        local delta = input.Position - dragStart
        MainFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
    end
end)

-- **NUEVO** Conectar el botón de minimizar
MinimizeButton.MouseButton1Click:Connect(ToggleMinimize)

-- Cerrar GUI
CloseButton.MouseButton1Click:Connect(function()
    -- Desactivar y limpiar todo
    if ESPConnection then ESPConnection:Disconnect(); ESPConnection = nil; end
    if speedGlitchConnection then speedGlitchConnection:Disconnect(); speedGlitchConnection = nil; end
    
    for _, player in pairs(Players:GetPlayers()) do RemoveESP(player) end
    for name, line in pairs(TracerLines) do line:Remove() end; TracerLines = {}
    for name, box in pairs(BoxESP) do for _, line in pairs(box) do line:Remove() end end; BoxESP = {}
    
    -- Restaurar velocidad del jugador local al cerrar
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") and originalWalkSpeed then
        LocalPlayer.Character.Humanoid.WalkSpeed = originalWalkSpeed
        originalWalkSpeed = nil
    end
    
    ScreenGui:Destroy()
end)

print("GUI Creada - Visual, Combat, Main | ESP en Visual | Speed Glitch en Main | Con botón minimizar")
print("Si no ves la GUI, revisa tu PlayerGui")
